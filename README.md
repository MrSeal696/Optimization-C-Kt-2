```markdown
# Оптимизация пузырьковой сортировки

## Описание проекта

Этот проект посвящён изучению и оптимизации алгоритма **пузырьковой сортировки** для повышения производительности при работе с массивами данных. В ходе работы реализованы две версии алгоритма: базовая и оптимизированная. Производительность алгоритмов сравнивалась на массивах разного размера и структуры.

## Цель проекта

Изучить работу пузырьковой сортировки, оптимизировать её производительность и провести сравнительный анализ времени выполнения до и после оптимизации.

## Алгоритм пузырьковой сортировки

### Базовая версия

Базовый алгоритм пузырьковой сортировки проходит по массиву \(n-1\) раз, сравнивая попарно соседние элементы. Если предыдущий элемент больше следующего, они меняются местами.

```csharp
static void BubbleSort(int[] arr)
{
    int n = arr.Length;
    for (int i = 0; i < n - 1; i++)
    {
        for (int j = 0; j < n - i - 1; j++)
        {
            if (arr[j] > arr[j + 1])
            {
                // Обмен элементов
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

### Оптимизированная версия

Добавлена проверка: если на текущей итерации не было обменов элементов, массив уже отсортирован, и выполнение алгоритма завершается. Это сокращает ненужные итерации в частично или полностью отсортированных массивах.

```csharp
static void OptimizedBubbleSort(int[] arr)
{
    int n = arr.Length;
    bool swapped;

    for (int i = 0; i < n - 1; i++)
    {
        swapped = false;

        for (int j = 0; j < n - i - 1; j++)
        {
            if (arr[j] > arr[j + 1])
            {
                // Обмен элементов
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = true;
            }
        }

        // Если элементы не обменивались, массив уже отсортирован
        if (!swapped) break;
    }
}
```

## Тестирование

Тестирование проводилось на массивах следующих размеров:
- **1,000**, **10,000** и **100,000 элементов**.
- Типы данных:
  - Случайный порядок.
  - Полностью отсортированные данные.
  - Данные в обратном порядке.

Для измерения времени выполнения использовался `Stopwatch`.

## Результаты тестирования

| Размер массива | Тип данных         | Время до оптимизации (ms) | Время после оптимизации (ms) |
|----------------|--------------------|---------------------------|------------------------------|
| 1,000          | Случайный порядок  | 2                         | 1                            |
| 1,000          | Отсортированный    | 2                         | <1                           |
| 1,000          | Обратный порядок   | 2                         | 1                            |
| 10,000         | Случайный порядок  | 215                       | 107                          |
| 10,000         | Отсортированный    | 211                       | <1                           |
| 10,000         | Обратный порядок   | 215                       | 107                          |
| 100,000        | Случайный порядок  | 23,784                    | 11,698                       |
| 100,000        | Отсортированный    | 23,749                    | <1                           |
| 100,000        | Обратный порядок   | 23,802                    | 11,692                       |

## Выводы

1. Оптимизация значительно сократила время выполнения для отсортированных и частично отсортированных массивов.
2. Для массивов в случайном и обратном порядке производительность также улучшилась, но не настолько сильно.
3. Оптимизация добавляет простую проверку на отсортированность массива, что минимизирует ненужные итерации без значительного увеличения сложности кода.

## Заключение

Оптимизированная версия пузырьковой сортировки лучше подходит для обработки данных, которые могут быть частично отсортированы. Однако, несмотря на улучшения, пузырьковая сортировка всё ещё остаётся неэффективной для работы с большими массивами. Для более масштабных задач рекомендуется использовать алгоритмы с \(O(n \log n)\) сложностью, такие как быстрая сортировка или сортировка слиянием.




